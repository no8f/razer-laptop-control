// This code was autogenerated with `dbus-codegen-rust -s -d org.freedesktop.login1 -p /org/freedesktop/login1 -m None`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::blocking;

pub trait OrgFreedesktopDBusPeer {
    fn ping(&self) -> Result<(), dbus::Error>;
    fn get_machine_id(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusPeer for blocking::Proxy<'a, C> {

    fn ping(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.DBus.Peer", "Ping", ())
    }

    fn get_machine_id(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Peer", "GetMachineId", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusIntrospectable for blocking::Proxy<'a, C> {

    fn introspect(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Introspectable", "Introspect", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }
}

pub trait OrgFreedesktopDBusProperties {
    fn get(&self, interface: &str, property: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error>;
    fn get_all(&self, interface: &str) -> Result<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error>;
    fn set(&self, interface: &str, property: &str, value: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusProperties for blocking::Proxy<'a, C> {

    fn get(&self, interface: &str, property: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Properties", "Get", (interface, property, ))
            .and_then(|r: (arg::Variant<Box<dyn arg::RefArg + 'static>>, )| Ok(r.0, ))
    }

    fn get_all(&self, interface: &str) -> Result<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Properties", "GetAll", (interface, ))
            .and_then(|r: (::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, )| Ok(r.0, ))
    }

    fn set(&self, interface: &str, property: &str, value: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.DBus.Properties", "Set", (interface, property, value, ))
    }
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface: String,
    pub changed_properties: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

// pub trait OrgFreedesktopLogin1Manager {
    // fn get_session(&self, session_id: &str) -> Result<dbus::Path<'static>, dbus::Error>;
    // fn get_session_by_pid(&self, pid: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    // fn get_user(&self, uid: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    // fn get_user_by_pid(&self, pid: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    // fn get_seat(&self, seat_id: &str) -> Result<dbus::Path<'static>, dbus::Error>;
    // fn list_sessions(&self) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, dbus::Error>;
    // fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, dbus::Error>;
    // fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::Error>;
    // fn list_inhibitors(&self) -> Result<Vec<(String, String, String, String, u32, u32)>, dbus::Error>;
    // fn create_session(&self, uid: u32, pid: u32, service: &str, type_: &str, class: &str, desktop: &str, seat_id: &str, vtnr: u32, tty: &str, display: &str, remote: bool, remote_user: &str, remote_host: &str, properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>) -> Result<(String, dbus::Path<'static>, String, arg::OwnedFd, u32, String, u32, bool), dbus::Error>;
    // fn release_session(&self, session_id: &str) -> Result<(), dbus::Error>;
    // fn activate_session(&self, session_id: &str) -> Result<(), dbus::Error>;
    // fn activate_session_on_seat(&self, session_id: &str, seat_id: &str) -> Result<(), dbus::Error>;
    // fn lock_session(&self, session_id: &str) -> Result<(), dbus::Error>;
    // fn unlock_session(&self, session_id: &str) -> Result<(), dbus::Error>;
    // fn lock_sessions(&self) -> Result<(), dbus::Error>;
    // fn unlock_sessions(&self) -> Result<(), dbus::Error>;
    // fn kill_session(&self, session_id: &str, who: &str, signal_number: i32) -> Result<(), dbus::Error>;
    // fn kill_user(&self, uid: u32, signal_number: i32) -> Result<(), dbus::Error>;
    // fn terminate_session(&self, session_id: &str) -> Result<(), dbus::Error>;
    // fn terminate_user(&self, uid: u32) -> Result<(), dbus::Error>;
    // fn terminate_seat(&self, seat_id: &str) -> Result<(), dbus::Error>;
    // fn set_user_linger(&self, uid: u32, enable: bool, interactive: bool) -> Result<(), dbus::Error>;
    // fn attach_device(&self, seat_id: &str, sysfs_path: &str, interactive: bool) -> Result<(), dbus::Error>;
    // fn flush_devices(&self, interactive: bool) -> Result<(), dbus::Error>;
    // fn power_off(&self, interactive: bool) -> Result<(), dbus::Error>;
    // fn reboot(&self, interactive: bool) -> Result<(), dbus::Error>;
    // fn halt(&self, interactive: bool) -> Result<(), dbus::Error>;
    // fn suspend(&self, interactive: bool) -> Result<(), dbus::Error>;
    // fn hibernate(&self, interactive: bool) -> Result<(), dbus::Error>;
    // fn hybrid_sleep(&self, interactive: bool) -> Result<(), dbus::Error>;
    // fn suspend_then_hibernate(&self, interactive: bool) -> Result<(), dbus::Error>;
    // fn can_power_off(&self) -> Result<String, dbus::Error>;
    // fn can_reboot(&self) -> Result<String, dbus::Error>;
    // fn can_halt(&self) -> Result<String, dbus::Error>;
    // fn can_suspend(&self) -> Result<String, dbus::Error>;
    // fn can_hibernate(&self) -> Result<String, dbus::Error>;
    // fn can_hybrid_sleep(&self) -> Result<String, dbus::Error>;
    // fn can_suspend_then_hibernate(&self) -> Result<String, dbus::Error>;
    // fn schedule_shutdown(&self, type_: &str, usec: u64) -> Result<(), dbus::Error>;
    // fn cancel_scheduled_shutdown(&self) -> Result<bool, dbus::Error>;
    // fn inhibit(&self, what: &str, who: &str, why: &str, mode: &str) -> Result<arg::OwnedFd, dbus::Error>;
    // fn can_reboot_parameter(&self) -> Result<String, dbus::Error>;
    // fn set_reboot_parameter_(&self, parameter: &str) -> Result<(), dbus::Error>;
    // fn can_reboot_to_firmware_setup(&self) -> Result<String, dbus::Error>;
    // fn set_reboot_to_firmware_setup_(&self, enable: bool) -> Result<(), dbus::Error>;
    // fn can_reboot_to_boot_loader_menu(&self) -> Result<String, dbus::Error>;
    // fn set_reboot_to_boot_loader_menu_(&self, timeout: u64) -> Result<(), dbus::Error>;
    // fn can_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error>;
    // fn set_reboot_to_boot_loader_entry_(&self, boot_loader_entry: &str) -> Result<(), dbus::Error>;
    // fn set_wall_message_(&self, wall_message: &str, enable: bool) -> Result<(), dbus::Error>;
    // fn enable_wall_messages(&self) -> Result<bool, dbus::Error>;
    // fn set_enable_wall_messages(&self, value: bool) -> Result<(), dbus::Error>;
    // fn wall_message(&self) -> Result<String, dbus::Error>;
    // fn set_wall_message(&self, value: String) -> Result<(), dbus::Error>;
    // fn nauto_vts(&self) -> Result<u32, dbus::Error>;
    // fn kill_only_users(&self) -> Result<Vec<String>, dbus::Error>;
    // fn kill_exclude_users(&self) -> Result<Vec<String>, dbus::Error>;
    // fn kill_user_processes(&self) -> Result<bool, dbus::Error>;
    // fn reboot_parameter(&self) -> Result<String, dbus::Error>;
    // fn reboot_to_firmware_setup(&self) -> Result<bool, dbus::Error>;
    // fn reboot_to_boot_loader_menu(&self) -> Result<u64, dbus::Error>;
    // fn reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error>;
    // fn boot_loader_entries(&self) -> Result<Vec<String>, dbus::Error>;
    // fn idle_hint(&self) -> Result<bool, dbus::Error>;
    // fn idle_since_hint(&self) -> Result<u64, dbus::Error>;
    // fn idle_since_hint_monotonic(&self) -> Result<u64, dbus::Error>;
    // fn block_inhibited(&self) -> Result<String, dbus::Error>;
    // fn delay_inhibited(&self) -> Result<String, dbus::Error>;
    // fn inhibit_delay_max_usec(&self) -> Result<u64, dbus::Error>;
    // fn user_stop_delay_usec(&self) -> Result<u64, dbus::Error>;
    // fn handle_power_key(&self) -> Result<String, dbus::Error>;
    // fn handle_suspend_key(&self) -> Result<String, dbus::Error>;
    // fn handle_hibernate_key(&self) -> Result<String, dbus::Error>;
    // fn handle_lid_switch(&self) -> Result<String, dbus::Error>;
    // fn handle_lid_switch_external_power(&self) -> Result<String, dbus::Error>;
    // fn handle_lid_switch_docked(&self) -> Result<String, dbus::Error>;
    // fn holdoff_timeout_usec(&self) -> Result<u64, dbus::Error>;
    // fn idle_action(&self) -> Result<String, dbus::Error>;
    // fn idle_action_usec(&self) -> Result<u64, dbus::Error>;
    // fn preparing_for_shutdown(&self) -> Result<bool, dbus::Error>;
    // fn preparing_for_sleep(&self) -> Result<bool, dbus::Error>;
    // fn scheduled_shutdown(&self) -> Result<(String, u64), dbus::Error>;
    // fn docked(&self) -> Result<bool, dbus::Error>;
    // fn lid_closed(&self) -> Result<bool, dbus::Error>;
    // fn on_external_power(&self) -> Result<bool, dbus::Error>;
    // fn remove_ipc(&self) -> Result<bool, dbus::Error>;
    // fn runtime_directory_size(&self) -> Result<u64, dbus::Error>;
    // fn runtime_directory_inodes_max(&self) -> Result<u64, dbus::Error>;
    // fn inhibitors_max(&self) -> Result<u64, dbus::Error>;
    // fn ncurrent_inhibitors(&self) -> Result<u64, dbus::Error>;
    // fn sessions_max(&self) -> Result<u64, dbus::Error>;
    // fn ncurrent_sessions(&self) -> Result<u64, dbus::Error>;
// }

// impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopLogin1Manager for blocking::Proxy<'a, C> {

    // fn get_session(&self, session_id: &str) -> Result<dbus::Path<'static>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "GetSession", (session_id, ))
            // .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    // }

    // fn get_session_by_pid(&self, pid: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "GetSessionByPID", (pid, ))
            // .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    // }

    // fn get_user(&self, uid: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "GetUser", (uid, ))
            // .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    // }

    // fn get_user_by_pid(&self, pid: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "GetUserByPID", (pid, ))
            // .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    // }

    // fn get_seat(&self, seat_id: &str) -> Result<dbus::Path<'static>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "GetSeat", (seat_id, ))
            // .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    // }

    // fn list_sessions(&self) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "ListSessions", ())
            // .and_then(|r: (Vec<(String, u32, String, String, dbus::Path<'static>)>, )| Ok(r.0, ))
    // }

    // fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "ListUsers", ())
            // .and_then(|r: (Vec<(u32, String, dbus::Path<'static>)>, )| Ok(r.0, ))
    // }

    // fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "ListSeats", ())
            // .and_then(|r: (Vec<(String, dbus::Path<'static>)>, )| Ok(r.0, ))
    // }

    // fn list_inhibitors(&self) -> Result<Vec<(String, String, String, String, u32, u32)>, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "ListInhibitors", ())
            // .and_then(|r: (Vec<(String, String, String, String, u32, u32)>, )| Ok(r.0, ))
    // }

    // fn create_session(&self, uid: u32, pid: u32, service: &str, type_: &str, class: &str, desktop: &str, seat_id: &str, vtnr: u32, tty: &str, display: &str, remote: bool, remote_user: &str, remote_host: &str, properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>) -> Result<(String, dbus::Path<'static>, String, arg::OwnedFd, u32, String, u32, bool), dbus::Error> {
        // // self.method_call("org.freedesktop.login1.Manager", "CreateSession", (uid, pid, service, type_, class, desktop, seat_id, vtnr, tty, display, remote, remote_user, remote_host, properties, ))
    // }

    // fn release_session(&self, session_id: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "ReleaseSession", (session_id, ))
    // }

    // fn activate_session(&self, session_id: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "ActivateSession", (session_id, ))
    // }

    // fn activate_session_on_seat(&self, session_id: &str, seat_id: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "ActivateSessionOnSeat", (session_id, seat_id, ))
    // }

    // fn lock_session(&self, session_id: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "LockSession", (session_id, ))
    // }

    // fn unlock_session(&self, session_id: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "UnlockSession", (session_id, ))
    // }

    // fn lock_sessions(&self) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "LockSessions", ())
    // }

    // fn unlock_sessions(&self) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "UnlockSessions", ())
    // }

    // fn kill_session(&self, session_id: &str, who: &str, signal_number: i32) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "KillSession", (session_id, who, signal_number, ))
    // }

    // fn kill_user(&self, uid: u32, signal_number: i32) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "KillUser", (uid, signal_number, ))
    // }

    // fn terminate_session(&self, session_id: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "TerminateSession", (session_id, ))
    // }

    // fn terminate_user(&self, uid: u32) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "TerminateUser", (uid, ))
    // }

    // fn terminate_seat(&self, seat_id: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "TerminateSeat", (seat_id, ))
    // }

    // fn set_user_linger(&self, uid: u32, enable: bool, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "SetUserLinger", (uid, enable, interactive, ))
    // }

    // fn attach_device(&self, seat_id: &str, sysfs_path: &str, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "AttachDevice", (seat_id, sysfs_path, interactive, ))
    // }

    // fn flush_devices(&self, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "FlushDevices", (interactive, ))
    // }

    // fn power_off(&self, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "PowerOff", (interactive, ))
    // }

    // fn reboot(&self, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "Reboot", (interactive, ))
    // }

    // fn halt(&self, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "Halt", (interactive, ))
    // }

    // fn suspend(&self, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "Suspend", (interactive, ))
    // }

    // fn hibernate(&self, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "Hibernate", (interactive, ))
    // }

    // fn hybrid_sleep(&self, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "HybridSleep", (interactive, ))
    // }

    // fn suspend_then_hibernate(&self, interactive: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "SuspendThenHibernate", (interactive, ))
    // }

    // fn can_power_off(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanPowerOff", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn can_reboot(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanReboot", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn can_halt(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanHalt", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn can_suspend(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanSuspend", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn can_hibernate(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanHibernate", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn can_hybrid_sleep(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanHybridSleep", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn can_suspend_then_hibernate(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanSuspendThenHibernate", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn schedule_shutdown(&self, type_: &str, usec: u64) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "ScheduleShutdown", (type_, usec, ))
    // }

    // fn cancel_scheduled_shutdown(&self) -> Result<bool, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CancelScheduledShutdown", ())
            // .and_then(|r: (bool, )| Ok(r.0, ))
    // }

    // fn inhibit(&self, what: &str, who: &str, why: &str, mode: &str) -> Result<arg::OwnedFd, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "Inhibit", (what, who, why, mode, ))
            // .and_then(|r: (arg::OwnedFd, )| Ok(r.0, ))
    // }

    // fn can_reboot_parameter(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanRebootParameter", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn set_reboot_parameter_(&self, parameter: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "SetRebootParameter", (parameter, ))
    // }

    // fn can_reboot_to_firmware_setup(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanRebootToFirmwareSetup", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn set_reboot_to_firmware_setup_(&self, enable: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "SetRebootToFirmwareSetup", (enable, ))
    // }

    // fn can_reboot_to_boot_loader_menu(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanRebootToBootLoaderMenu", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn set_reboot_to_boot_loader_menu_(&self, timeout: u64) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "SetRebootToBootLoaderMenu", (timeout, ))
    // }

    // fn can_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "CanRebootToBootLoaderEntry", ())
            // .and_then(|r: (String, )| Ok(r.0, ))
    // }

    // fn set_reboot_to_boot_loader_entry_(&self, boot_loader_entry: &str) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "SetRebootToBootLoaderEntry", (boot_loader_entry, ))
    // }

    // fn set_wall_message_(&self, wall_message: &str, enable: bool) -> Result<(), dbus::Error> {
        // self.method_call("org.freedesktop.login1.Manager", "SetWallMessage", (wall_message, enable, ))
    // }

    // fn enable_wall_messages(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "EnableWallMessages")
    // }

    // fn wall_message(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "WallMessage")
    // }

    // fn nauto_vts(&self) -> Result<u32, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NAutoVTs")
    // }

    // fn kill_only_users(&self) -> Result<Vec<String>, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillOnlyUsers")
    // }

    // fn kill_exclude_users(&self) -> Result<Vec<String>, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillExcludeUsers")
    // }

    // fn kill_user_processes(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillUserProcesses")
    // }

    // fn reboot_parameter(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootParameter")
    // }

    // fn reboot_to_firmware_setup(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootToFirmwareSetup")
    // }

    // fn reboot_to_boot_loader_menu(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootToBootLoaderMenu")
    // }

    // fn reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootToBootLoaderEntry")
    // }

    // fn boot_loader_entries(&self) -> Result<Vec<String>, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "BootLoaderEntries")
    // }

    // fn idle_hint(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleHint")
    // }

    // fn idle_since_hint(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleSinceHint")
    // }

    // fn idle_since_hint_monotonic(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleSinceHintMonotonic")
    // }

    // fn block_inhibited(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "BlockInhibited")
    // }

    // fn delay_inhibited(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "DelayInhibited")
    // }

    // fn inhibit_delay_max_usec(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "InhibitDelayMaxUSec")
    // }

    // fn user_stop_delay_usec(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "UserStopDelayUSec")
    // }

    // fn handle_power_key(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandlePowerKey")
    // }

    // fn handle_suspend_key(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleSuspendKey")
    // }

    // fn handle_hibernate_key(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleHibernateKey")
    // }

    // fn handle_lid_switch(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleLidSwitch")
    // }

    // fn handle_lid_switch_external_power(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleLidSwitchExternalPower")
    // }

    // fn handle_lid_switch_docked(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleLidSwitchDocked")
    // }

    // fn holdoff_timeout_usec(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HoldoffTimeoutUSec")
    // }

    // fn idle_action(&self) -> Result<String, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleAction")
    // }

    // fn idle_action_usec(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleActionUSec")
    // }

    // fn preparing_for_shutdown(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "PreparingForShutdown")
    // }

    // fn preparing_for_sleep(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "PreparingForSleep")
    // }

    // fn scheduled_shutdown(&self) -> Result<(String, u64), dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "ScheduledShutdown")
    // }

    // fn docked(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "Docked")
    // }

    // fn lid_closed(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "LidClosed")
    // }

    // fn on_external_power(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "OnExternalPower")
    // }

    // fn remove_ipc(&self) -> Result<bool, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RemoveIPC")
    // }

    // fn runtime_directory_size(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RuntimeDirectorySize")
    // }

    // fn runtime_directory_inodes_max(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RuntimeDirectoryInodesMax")
    // }

    // fn inhibitors_max(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "InhibitorsMax")
    // }

    // fn ncurrent_inhibitors(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NCurrentInhibitors")
    // }

    // fn sessions_max(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "SessionsMax")
    // }

    // fn ncurrent_sessions(&self) -> Result<u64, dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NCurrentSessions")
    // }

    // fn set_enable_wall_messages(&self, value: bool) -> Result<(), dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.login1.Manager", "EnableWallMessages", value)
    // }

    // fn set_wall_message(&self, value: String) -> Result<(), dbus::Error> {
        // <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.login1.Manager", "WallMessage", value)
    // }
// }

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSessionNew {
    pub session_id: String,
    pub object_path: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSessionNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_id, i);
        arg::RefArg::append(&self.object_path, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSessionNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerSessionNew {
            session_id: i.read()?,
            object_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSessionNew {
    const NAME: &'static str = "SessionNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSessionRemoved {
    pub session_id: String,
    pub object_path: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSessionRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_id, i);
        arg::RefArg::append(&self.object_path, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSessionRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerSessionRemoved {
            session_id: i.read()?,
            object_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSessionRemoved {
    const NAME: &'static str = "SessionRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerUserNew {
    pub uid: u32,
    pub object_path: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerUserNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.uid, i);
        arg::RefArg::append(&self.object_path, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerUserNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerUserNew {
            uid: i.read()?,
            object_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerUserNew {
    const NAME: &'static str = "UserNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerUserRemoved {
    pub uid: u32,
    pub object_path: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerUserRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.uid, i);
        arg::RefArg::append(&self.object_path, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerUserRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerUserRemoved {
            uid: i.read()?,
            object_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerUserRemoved {
    const NAME: &'static str = "UserRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSeatNew {
    pub seat_id: String,
    pub object_path: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSeatNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.seat_id, i);
        arg::RefArg::append(&self.object_path, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSeatNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerSeatNew {
            seat_id: i.read()?,
            object_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSeatNew {
    const NAME: &'static str = "SeatNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSeatRemoved {
    pub seat_id: String,
    pub object_path: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSeatRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.seat_id, i);
        arg::RefArg::append(&self.object_path, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSeatRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerSeatRemoved {
            seat_id: i.read()?,
            object_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSeatRemoved {
    const NAME: &'static str = "SeatRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerPrepareForShutdown {
    pub start: bool,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerPrepareForShutdown {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.start, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerPrepareForShutdown {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerPrepareForShutdown {
            start: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForShutdown {
    const NAME: &'static str = "PrepareForShutdown";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerPrepareForSleep {
    pub start: bool,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerPrepareForSleep {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.start, i);
    }
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerPrepareForSleep {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopLogin1ManagerPrepareForSleep {
            start: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForSleep {
    const NAME: &'static str = "PrepareForSleep";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}
